自定义圆形view，可选择颜色，内外边框。

![](http://github.com/callmexiaolu/callmexiaolu.github.io/raw/master/img/post-img-view.png)

```kotl

/**
 *Create by LuKaiqi on 2019/7/1.
 *function:圆形头像，可以添加外边框，内边框，设置边框颜色
 */
class CircleAvatarView : AppCompatImageView {

    var mBorderColor: Int = 0 //边框颜色
        set(@ColorRes value) {
            field = value
            initBorderPaint()
            invalidate()
        }
    var mBorderWidth: Int = 0 //边框宽度
        set(value) {
            field = value
            invalidate()
        }
    var mIsInner: Boolean = false //是否为内边框
        set(value) {
            field = value
            invalidate()
        }

    private var mWidth = 0
    private var mRadius = 0f

    private val mBitmapPaint = Paint()
    private val mBorderPaint = Paint()
    private val mMatrix = Matrix()
    private lateinit var mBitmap: Bitmap
    private lateinit var mBitmapShader: BitmapShader
    private var mBitmapSize = 1
    private var mScale = 0f

    constructor(context: Context) : this(context, null)

    constructor(context: Context, attributes: AttributeSet?) : this(context, attributes, 0)

    constructor(context: Context, attributes: AttributeSet?, defStyle: Int) : super(context, attributes, defStyle) {
        val typedArray = context.obtainStyledAttributes(
            attributes,
            R.styleable.CircleAvatarView,
            0,
            0
        )
        mBorderColor = typedArray.getColor(R.styleable.CircleAvatarView_border_color, Color.WHITE)
        mBorderWidth = typedArray.getDimensionPixelSize(R.styleable.CircleAvatarView_border_width, 0)
        mIsInner = typedArray.getBoolean(R.styleable.CircleAvatarView_is_inner, false)
        typedArray.recycle()
        mBitmapPaint.isAntiAlias = true
        initBorderPaint()
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        mWidth = if (mIsInner) {
            min(measuredWidth, measuredHeight)
        } else {
            min(measuredWidth, measuredHeight) + mBorderWidth * 2
        }
        mRadius = mWidth / 2f
        setMeasuredDimension(mWidth, mWidth) //让view宽高一样
        initBitmapShader()
    }

    override fun onDraw(canvas: Canvas) {
        if (!::mBitmap.isInitialized && !::mBitmapShader.isInitialized) {
            initBitmapShader()
        }
        if (mIsInner) {
            canvas.drawCircle(mRadius, mRadius, mRadius, mBitmapPaint)
            canvas.drawCircle(mRadius, mRadius, mRadius - mBorderWidth / 2, mBorderPaint)
        } else {
            canvas.drawCircle(mRadius, mRadius, mRadius - mBorderWidth, mBitmapPaint)
            canvas.drawCircle(mRadius, mRadius, mRadius - mBorderWidth / 2, mBorderPaint)
        }
    }

    /**
     * drawable转bitmap
     */
    private fun getBitmap(drawable: Drawable): Bitmap {
        if (drawable is BitmapDrawable) {
            return drawable.bitmap
        }
        val w = drawable.intrinsicWidth
        val h = drawable.intrinsicHeight
        val bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)
        drawable.setBounds(0, 0, w, h)
        drawable.draw(Canvas(bitmap))
        return bitmap
    }

    private fun initBitmapShader() {
        drawable?.run {
            if (!::mBitmap.isInitialized) {
                mBitmap = getBitmap(this)
                mBitmapShader = BitmapShader(getBitmap(this), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
            }
            //检查当前绘制的bitmap是不是最新的
            if (mBitmap != getBitmap(this)) {
                mBitmap = getBitmap(this)
                mBitmapShader = BitmapShader(getBitmap(this), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
            }
            mBitmapSize = min(mBitmap.width, mBitmap.height)
            mScale = mWidth * 1.0f / mBitmapSize
            //矩阵变换，用于放大缩小
            mMatrix.setScale(mScale, mScale)
            //设置变换矩阵
            mBitmapShader.setLocalMatrix(mMatrix)
            //设置shader
            mBitmapPaint.shader = mBitmapShader
        }
    }

    private fun initBorderPaint() {
        mBorderPaint.reset()
        mBorderPaint.isAntiAlias = true
        mBorderPaint.color = mBorderColor
        mBorderPaint.strokeWidth = mBorderWidth.toFloat()
        mBorderPaint.style = Paint.Style.STROKE
    }

}
```

